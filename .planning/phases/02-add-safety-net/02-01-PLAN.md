---
phase: 02-add-safety-net
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/components/ErrorBoundary.tsx, src/App.tsx]
autonomous: true

must_haves:
  truths:
    - "Runtime errors in Oracle show fallback UI instead of white screen"
    - "Error boundary catches and displays errors gracefully"
    - "Site works exactly as before when no errors occur"
  artifacts:
    - path: "src/components/ErrorBoundary.tsx"
      provides: "Error boundary component"
      exports: ["ErrorBoundary"]
    - path: "src/App.tsx"
      provides: "App wrapped in ErrorBoundary"
      contains: "ErrorBoundary"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/ErrorBoundary.tsx"
      via: "import and wrap"
      pattern: "import.*ErrorBoundary"
---

<objective>
Add error boundary component to catch runtime errors.

Purpose: Prevent white screen of death when errors occur. Show graceful fallback UI.
Output: ErrorBoundary component wrapping the app.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Relevant source files:
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorBoundary component</name>
  <files>src/components/ErrorBoundary.tsx</files>
  <action>Create src/components/ErrorBoundary.tsx with:
  1. Class component (error boundaries require class components)
  2. componentDidCatch to log errors to console
  3. getDerivedStateFromError to set error state
  4. Fallback UI that:
     - Shows "Something went wrong" message
     - Has a "Refresh" button that calls window.location.reload()
     - Styled to match site aesthetic (dark background, centered text)
     - Does NOT change the visual style of normal app operation

  Keep the fallback simple - just enough to inform user and let them recover.</action>
  <verify>tsc --noEmit passes</verify>
  <done>ErrorBoundary component exists and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Wrap App in ErrorBoundary</name>
  <files>src/App.tsx</files>
  <action>Edit App.tsx to:
  1. Import ErrorBoundary from ./components/ErrorBoundary
  2. Wrap the BrowserRouter (and its contents) with ErrorBoundary
  3. Keep Analytics outside ErrorBoundary (so analytics still work even if app crashes)

  Structure should be:
  ```
  <ErrorBoundary>
    <BrowserRouter>
      <Routes>...</Routes>
    </BrowserRouter>
  </ErrorBoundary>
  <Analytics />
  ```</action>
  <verify>npm run build succeeds</verify>
  <done>App.tsx wraps content in ErrorBoundary</done>
</task>

<task type="auto">
  <name>Task 3: Verify build passes</name>
  <files></files>
  <action>Run npm run build to verify everything compiles correctly.</action>
  <verify>npm run build exits with code 0</verify>
  <done>Build passes, no type errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] ErrorBoundary.tsx exists in src/components/
- [ ] App.tsx imports and uses ErrorBoundary
- [ ] ErrorBoundary wraps BrowserRouter but not Analytics
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- ErrorBoundary component created
- App wrapped in ErrorBoundary
</success_criteria>

<output>
After completion, create `.planning/phases/02-add-safety-net/02-01-SUMMARY.md`
</output>
